---
title: 2024.NSS秋季赛
date: 2024-10-08 16:22:48
tags: 
      - 复现
      - crypto
categories: 比赛复现
---

### Crypto

### Aftermath

共模攻击

```
from Crypto.Util.number import long_to_bytes
from gmpy2 import gcdext
c2 = 13491956530007991248882899018888359080930858500993821006822695375714947537976202424265808646466853291165511243721829370428583392329886743499827454177786585477285598196204906977043127274613692623229137936467994670727274820568522666762615055848367486507714640497446688083840123758417442971555904294548595887600
n = 80722936701364382749961243326484006977187702986017980842794443374132452156776306032868217795522046975068822236770836452911408536092460646410756678157902792329645719935468879960944028782788489463895870961967670931567205550383999951787250211085264314795753745003815839218062934564501884684565508432346164094171
e1 = 3
c1 = 77027474990431732719325428265107176934045610651944725251406683442684093440239073195437770144166442593914418380343458827052860752131667771506129334676070396374008929588455988149871039697387983766750148969695215583137356681988572655848921827794639096404716760310059622671470680330144220097050812716421370445797
e2 = 7
s,s1,s2=gcdext(e1,e2)
m = ((pow(c1,s1,n)*pow(c2,s2,n)) % n)
print(m)
print(long_to_bytes(m))

//NSSCTF{It all played out with my life on pause
```

### 泰坦陨落2

他给了我们两文件

```
# LCG参数
a = 1664525
c = 1013904223
m = 2**32

# 妙蛙种子
seed = .........

# 生成伪随机数
def lcg(seed, n):
    numbers = []
    for _ in range(n):
        seed = (a * seed + c) % m
        numbers.append(seed)
    return numbers

# 给你5个伪随机数
random_numbers = lcg(seed, 5)
print(random_numbers)
#[3771924608, 3319331295, 583630258, 2401321321, 611326900]
```

```
def xor_encrypt_decrypt(data, key):

    key_bytes = key.to_bytes((key.bit_length() + 7) // 8, 'big')
    key_length = len(key_bytes)

    result = bytearray()
    for i in range(len(data)):
        result.append(data[i] ^ key_bytes[i % key_length])

    return bytes(result)

flag = "NSSCTF{........................................}"

flag_bytes = flag.encode('utf-8')

# 使用妙蛙种子进行加密,如果你没有妙蛙种子，请先去克莱伯那里拿妙蛙种子
key = seed
encrypted_bytes = xor_encrypt_decrypt(flag_bytes, key)

# 输出加密后的字节和字符串
print("Encrypted Bytes:", encrypted_bytes)
#Encrypted Bytes: b"n2!&t'\t\x06A\x14\x01\x00\x00\x16\x17EA\x13\x17ET\t\x17EC\x0e\x1e\nR\x12R\x0cNA\x06\rEA\x16\x04R\n\x0f"
```

第一个是伪随机数样本

第二个时flag加密文件

我们逆向第一个文件，得到seed值

```
# LCG参数
a = 1664525
c = 1013904223
m = 4294967296

# 给定的随机数序列
random_numbers = [3771924608, 3319331295, 583630258, 2401321321, 611326900]

# 反向推导种子
def find_seed(random_numbers):
    # 从第一个随机数反推种子
    next_num = random_numbers[0]
    seed = (next_num - c) % m
    seed = (seed * pow(a, -1, m)) % m  # 使用模逆来求seed
    return seed

seed = find_seed(random_numbers)
print(seed)
```

第二个因为 XOR 加密是对称的，解密过程与加密过程相同。使用相同的密钥对加密数据进行 XOR 操作，可以还原出原始数据。

```
def xor_encrypt_decrypt(data, key):
    key_bytes = key.to_bytes((key.bit_length() + 7) // 8, 'big')
    key_length = len(key_bytes)
    result = bytearray()
    for i in range(len(data)):
        result.append(data[i] ^ key_bytes[i % key_length])
    return bytes(result)

# 使用妙蛙种子进行加密,如果你没有妙蛙种子，请先去克莱伯那里拿妙蛙种子
key = 543257189
encrypted_bytes = b"n2!&t'\t\x06A\x14\x01\x00\x00\x16\x17EA\x13\x17ET\t\x17EC\x0e\x1e\nR\x12R\x0cNA\x06\rEA\x16\x04R\n\x0f"
# 输出加密后的字节和字符串
# 解密过程
decrypted_bytes = xor_encrypt_decrypt(encrypted_bytes, key)
decrypted_flag = decrypted_bytes.decode('utf-8')
print("Decrypted Flag:", decrypted_flag)
//NSSCTF{cause we are the colors in the dark}
```

### Take what you want

文件有个hint，提示我们键盘

我们跟着字符在键盘上的轨迹，可以发现具体的字母

![image-20241008163138745](https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202410081631850.png)
